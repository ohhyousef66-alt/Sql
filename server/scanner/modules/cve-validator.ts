/**
 * CVE Validation and Filtering Layer
 * 
 * CORE PRINCIPLE: "It is acceptable to miss CVEs. It is NOT acceptable to report incorrect CVEs."
 * 
 * This module implements strict validation to eliminate false CVE reports.
 * When in doubt, DO NOT REPORT.
 */

export interface TechnologyStack {
  technologies: Technology[];
  headers: Record<string, string>;
  isCustomBuilt: boolean;
  signalCounts: Record<string, SignalDetails>;
}

export interface Technology {
  name: string;
  version?: string;
  confidence: "high" | "medium" | "low";
  category: "cms" | "framework" | "server" | "language" | "library";
}

export interface SignalDetails {
  count: number;
  sources: SignalSource[];
}

export type SignalSource = 
  | "header"
  | "meta_tag"
  | "file_path"
  | "error_message"
  | "js_library"
  | "cookie"
  | "response_content"
  | "specific_endpoint";

export interface CVEFinding {
  cveId: string;
  category: "confirmed" | "possible" | "not_scannable";
  technology: string;
  version: string;
  confidence: number;
  validationDetails: string[];
  suppressionReason?: string;
}

export interface CVESuppressionRules {
  isCustomBuilt: boolean;
  detectedComponents: string[];
  cveExploitType: "remote-http" | "memory" | "internal" | "config-dependent";
}

interface CVEMetadata {
  id: string;
  technology: string;
  affectedVersions: VersionRange;
  exploitType: "remote-http" | "memory" | "internal" | "config-dependent";
  requiresAuthentication: boolean;
  requiresSpecificConfig: boolean;
  httpReachable: boolean;
  incompatibleWith: string[];
  description: string;
  severity: string;
}

interface VersionRange {
  min?: string;
  max?: string;
  fixed?: string;
  specific?: string[];
}

const CVE_METADATA: Record<string, CVEMetadata> = {
  "CVE-2023-2982": {
    id: "CVE-2023-2982",
    technology: "wordpress",
    affectedVersions: { max: "6.2.0" },
    exploitType: "remote-http",
    requiresAuthentication: false,
    requiresSpecificConfig: false,
    httpReachable: true,
    incompatibleWith: ["aspnet", "iis", "java", "django", "rails"],
    description: "WordPress Core < 6.2.1 - Cross-Site Scripting",
    severity: "Medium",
  },
  "CVE-2023-28121": {
    id: "CVE-2023-28121",
    technology: "woocommerce",
    affectedVersions: { max: "5.6.1" },
    exploitType: "remote-http",
    requiresAuthentication: false,
    requiresSpecificConfig: true,
    httpReachable: true,
    incompatibleWith: ["aspnet", "iis", "java", "django", "rails"],
    description: "WooCommerce Payments < 5.6.2 - Authentication Bypass",
    severity: "Critical",
  },
  "CVE-2023-23488": {
    id: "CVE-2023-23488",
    technology: "contact-form-7",
    affectedVersions: {},
    exploitType: "remote-http",
    requiresAuthentication: false,
    requiresSpecificConfig: true,
    httpReachable: true,
    incompatibleWith: ["aspnet", "iis", "java", "django", "rails"],
    description: "WordPress Plugin Contact Form 7 - SQL Injection",
    severity: "High",
  },
  "CVE-2023-23752": {
    id: "CVE-2023-23752",
    technology: "joomla",
    affectedVersions: { max: "4.2.7" },
    exploitType: "remote-http",
    requiresAuthentication: false,
    requiresSpecificConfig: false,
    httpReachable: true,
    incompatibleWith: ["aspnet", "iis", "wordpress", "drupal"],
    description: "Joomla! < 4.2.8 - Unauthenticated Information Disclosure",
    severity: "High",
  },
  "CVE-2023-23753": {
    id: "CVE-2023-23753",
    technology: "joomla",
    affectedVersions: { max: "4.2.7" },
    exploitType: "remote-http",
    requiresAuthentication: true,
    requiresSpecificConfig: false,
    httpReachable: true,
    incompatibleWith: ["aspnet", "iis", "wordpress", "drupal"],
    description: "Joomla! < 4.2.8 - Improper Access Control",
    severity: "Medium",
  },
  "CVE-2019-6340": {
    id: "CVE-2019-6340",
    technology: "drupal",
    affectedVersions: { min: "8.5.0", max: "8.6.9" },
    exploitType: "remote-http",
    requiresAuthentication: false,
    requiresSpecificConfig: true,
    httpReachable: true,
    incompatibleWith: ["aspnet", "iis", "wordpress", "joomla"],
    description: "Drupal Core - Remote Code Execution",
    severity: "Critical",
  },
  "CVE-2018-7600": {
    id: "CVE-2018-7600",
    technology: "drupal",
    affectedVersions: { max: "8.5.0" },
    exploitType: "remote-http",
    requiresAuthentication: false,
    requiresSpecificConfig: false,
    httpReachable: true,
    incompatibleWith: ["aspnet", "iis", "wordpress", "joomla"],
    description: "Drupalgeddon2 - Remote Code Execution",
    severity: "Critical",
  },
  "CVE-2021-41773": {
    id: "CVE-2021-41773",
    technology: "apache",
    affectedVersions: { specific: ["2.4.49"] },
    exploitType: "remote-http",
    requiresAuthentication: false,
    requiresSpecificConfig: true,
    httpReachable: true,
    incompatibleWith: ["nginx", "iis"],
    description: "Apache HTTP Server 2.4.49 - Path Traversal",
    severity: "Critical",
  },
  "CVE-2021-42013": {
    id: "CVE-2021-42013",
    technology: "apache",
    affectedVersions: { specific: ["2.4.49", "2.4.50"] },
    exploitType: "remote-http",
    requiresAuthentication: false,
    requiresSpecificConfig: true,
    httpReachable: true,
    incompatibleWith: ["nginx", "iis"],
    description: "Apache HTTP Server 2.4.50 - Path Traversal & RCE",
    severity: "Critical",
  },
  "CVE-2021-23017": {
    id: "CVE-2021-23017",
    technology: "nginx",
    affectedVersions: { max: "1.21.0" },
    exploitType: "memory",
    requiresAuthentication: false,
    requiresSpecificConfig: true,
    httpReachable: false,
    incompatibleWith: ["apache", "iis"],
    description: "Nginx Resolver Off-by-One Heap Write",
    severity: "High",
  },
  "CVE-2019-11043": {
    id: "CVE-2019-11043",
    technology: "php",
    affectedVersions: { max: "7.3.10" },
    exploitType: "remote-http",
    requiresAuthentication: false,
    requiresSpecificConfig: true,
    httpReachable: true,
    incompatibleWith: ["aspnet", "java"],
    description: "PHP-FPM Remote Code Execution",
    severity: "Critical",
  },
};

const INFRASTRUCTURE_TECHNOLOGIES = ["nginx", "apache", "iis", "openssl", "linux", "windows"];
const PHP_BASED_TECHNOLOGIES = ["wordpress", "joomla", "drupal", "magento", "php", "laravel"];
const DOTNET_TECHNOLOGIES = ["aspnet", "iis"];

const MINIMUM_SIGNALS_FOR_CVE = 2;

export function validateCVE(
  cveId: string,
  technology: string,
  version: string,
  signals: string[]
): CVEFinding | null {
  const metadata = CVE_METADATA[cveId];
  const validationDetails: string[] = [];
  
  if (!metadata) {
    return {
      cveId,
      category: "not_scannable",
      technology,
      version: version || "unknown",
      confidence: 0,
      validationDetails: ["CVE not in validation database - cannot verify applicability"],
      suppressionReason: "CVE metadata not available for validation",
    };
  }

  if (signals.length < MINIMUM_SIGNALS_FOR_CVE) {
    return {
      cveId,
      category: "not_scannable",
      technology,
      version: version || "unknown",
      confidence: 0,
      validationDetails: [
        `Insufficient signals for technology confirmation: ${signals.length} < ${MINIMUM_SIGNALS_FOR_CVE}`,
        `Signals provided: ${signals.join(", ") || "none"}`,
      ],
      suppressionReason: `Technology not confirmed - requires ${MINIMUM_SIGNALS_FOR_CVE}+ independent signals, got ${signals.length}`,
    };
  }

  validationDetails.push(`Technology confirmed via ${signals.length} signals: ${signals.join(", ")}`);

  if (!version) {
    if (INFRASTRUCTURE_TECHNOLOGIES.includes(technology.toLowerCase())) {
      return {
        cveId,
        category: "not_scannable",
        technology,
        version: "unknown",
        confidence: 0,
        validationDetails: [
          ...validationDetails,
          "Infrastructure CVE requires exact version confirmation",
        ],
        suppressionReason: "Server/infrastructure CVE cannot be validated without confirmed version",
      };
    }
    
    return {
      cveId,
      category: "possible",
      technology,
      version: "unknown",
      confidence: 30,
      validationDetails: [
        ...validationDetails,
        "Version not confirmed - CVE applicability uncertain",
        "Downgraded to 'possible' due to missing version information",
      ],
    };
  }

  const versionValid = isVersionAffected(version, metadata.affectedVersions);
  if (!versionValid.affected) {
    return {
      cveId,
      category: "not_scannable",
      technology,
      version,
      confidence: 0,
      validationDetails: [
        ...validationDetails,
        `Version ${version} not in affected range`,
        versionValid.reason,
      ],
      suppressionReason: `Detected version ${version} is not vulnerable to ${cveId}`,
    };
  }

  validationDetails.push(`Version ${version} is within affected range: ${versionValid.reason}`);

  if (!metadata.httpReachable) {
    return {
      cveId,
      category: "not_scannable",
      technology,
      version,
      confidence: 0,
      validationDetails: [
        ...validationDetails,
        `CVE exploit type: ${metadata.exploitType}`,
        "Not exploitable via HTTP black-box testing",
      ],
      suppressionReason: `${cveId} is not remotely exploitable via HTTP (type: ${metadata.exploitType})`,
    };
  }

  validationDetails.push("CVE is HTTP-reachable for black-box testing");

  if (metadata.requiresSpecificConfig) {
    validationDetails.push("WARNING: CVE requires specific configuration that cannot be verified");
    
    return {
      cveId,
      category: "possible",
      technology,
      version,
      confidence: 50,
      validationDetails: [
        ...validationDetails,
        "Downgraded to 'possible' - specific configuration requirements cannot be validated",
      ],
    };
  }

  if (metadata.requiresAuthentication) {
    validationDetails.push("CVE requires authenticated access");
    
    return {
      cveId,
      category: "possible",
      technology,
      version,
      confidence: 40,
      validationDetails: [
        ...validationDetails,
        "Downgraded to 'possible' - requires authentication to exploit",
      ],
    };
  }

  return {
    cveId,
    category: "confirmed",
    technology,
    version,
    confidence: 85,
    validationDetails: [
      ...validationDetails,
      "All validation criteria passed",
      "Technology confirmed, version in affected range, HTTP-reachable, no special requirements",
    ],
  };
}

export function shouldSuppressCVE(
  cveId: string,
  detectedStack: TechnologyStack
): { suppress: boolean; reason: string } {
  const metadata = CVE_METADATA[cveId];
  
  if (!metadata) {
    return {
      suppress: true,
      reason: "CVE not in validation database - suppressing unknown CVE to prevent false positives",
    };
  }

  if (detectedStack.isCustomBuilt) {
    const cmsTechnologies = ["wordpress", "joomla", "drupal", "magento", "shopify"];
    if (cmsTechnologies.includes(metadata.technology.toLowerCase())) {
      return {
        suppress: true,
        reason: `Target appears to be custom-built application - suppressing CMS-specific CVE (${metadata.technology})`,
      };
    }
  }

  const detectedTechNames = detectedStack.technologies.map(t => t.name.toLowerCase());
  
  for (const incompatible of metadata.incompatibleWith) {
    if (detectedTechNames.includes(incompatible.toLowerCase())) {
      return {
        suppress: true,
        reason: `Incompatible technology detected: ${incompatible} conflicts with ${metadata.technology}`,
      };
    }
  }

  const hasDotNet = detectedTechNames.some(t => DOTNET_TECHNOLOGIES.includes(t));
  if (hasDotNet && PHP_BASED_TECHNOLOGIES.includes(metadata.technology.toLowerCase())) {
    return {
      suppress: true,
      reason: `ASP.NET stack detected - PHP-based CVE (${metadata.technology}) is not applicable`,
    };
  }

  if (!detectedTechNames.includes(metadata.technology.toLowerCase())) {
    const relatedTech = getRelatedTechnologies(metadata.technology);
    const hasRelated = relatedTech.some(t => detectedTechNames.includes(t.toLowerCase()));
    
    if (!hasRelated) {
      return {
        suppress: true,
        reason: `Required technology '${metadata.technology}' not detected in stack`,
      };
    }
  }

  if (metadata.exploitType === "memory") {
    return {
      suppress: true,
      reason: "Memory corruption vulnerability - not exploitable via web scanning",
    };
  }

  if (metadata.exploitType === "internal") {
    return {
      suppress: true,
      reason: "Internal-only vulnerability - not accessible via external HTTP testing",
    };
  }

  if (metadata.exploitType === "config-dependent" && metadata.requiresSpecificConfig) {
    return {
      suppress: false,
      reason: "Config-dependent CVE - will be marked as 'possible' not 'confirmed'",
    };
  }

  const signalDetails = detectedStack.signalCounts[metadata.technology.toLowerCase()];
  if (!signalDetails || signalDetails.count < MINIMUM_SIGNALS_FOR_CVE) {
    return {
      suppress: true,
      reason: `Insufficient technology signals: ${signalDetails?.count || 0} < ${MINIMUM_SIGNALS_FOR_CVE} required`,
    };
  }

  return {
    suppress: false,
    reason: "CVE passed all suppression checks",
  };
}

export function isRemotelyExploitable(cveId: string): boolean {
  const metadata = CVE_METADATA[cveId];
  
  if (!metadata) {
    return false;
  }

  if (!metadata.httpReachable) {
    return false;
  }

  if (metadata.exploitType === "memory" || metadata.exploitType === "internal") {
    return false;
  }

  return true;
}

export function countTechnologySignals(
  technology: string,
  sources: SignalSource[]
): SignalDetails {
  const uniqueSources = Array.from(new Set(sources));
  return {
    count: uniqueSources.length,
    sources: uniqueSources,
  };
}

export function buildTechnologyStack(
  technologies: Technology[],
  headers: Record<string, string>,
  contentSignals: Record<string, SignalSource[]>
): TechnologyStack {
  const signalCounts: Record<string, SignalDetails> = {};
  
  for (const tech of technologies) {
    const sources = contentSignals[tech.name.toLowerCase()] || [];
    signalCounts[tech.name.toLowerCase()] = countTechnologySignals(tech.name, sources);
  }

  const isCustomBuilt = determineIfCustomBuilt(technologies, headers);

  return {
    technologies,
    headers,
    isCustomBuilt,
    signalCounts,
  };
}

function determineIfCustomBuilt(
  technologies: Technology[],
  headers: Record<string, string>
): boolean {
  const knownCMS = ["wordpress", "joomla", "drupal", "magento", "shopify"];
  const hasCMS = technologies.some(t => knownCMS.includes(t.name.toLowerCase()));
  
  if (hasCMS) {
    return false;
  }

  const hasModernFramework = technologies.some(t => 
    ["react", "angular", "vuejs", "nextjs", "nuxt"].includes(t.name.toLowerCase())
  );
  
  const hasCustomAPI = technologies.some(t =>
    ["express", "fastify", "koa", "django", "rails", "laravel", "aspnet"].includes(t.name.toLowerCase())
  );

  if (hasModernFramework && hasCustomAPI) {
    return true;
  }

  const techCategories = technologies.map(t => t.category);
  const hasMixedStack = 
    techCategories.includes("library") && 
    techCategories.includes("framework") &&
    !techCategories.includes("cms");

  return hasMixedStack;
}

function isVersionAffected(
  version: string,
  range: VersionRange
): { affected: boolean; reason: string } {
  if (range.specific && range.specific.length > 0) {
    const isSpecific = range.specific.includes(version);
    return {
      affected: isSpecific,
      reason: isSpecific 
        ? `Version ${version} is in specific affected versions list` 
        : `Version ${version} not in specific affected versions: ${range.specific.join(", ")}`,
    };
  }

  const versionParts = version.split(".").map(p => parseInt(p, 10) || 0);
  
  if (range.fixed) {
    const fixedParts = range.fixed.split(".").map(p => parseInt(p, 10) || 0);
    const isBeforeFixed = compareVersions(versionParts, fixedParts) < 0;
    return {
      affected: isBeforeFixed,
      reason: isBeforeFixed 
        ? `Version ${version} is before fixed version ${range.fixed}`
        : `Version ${version} is at or after fixed version ${range.fixed}`,
    };
  }

  if (range.min && range.max) {
    const minParts = range.min.split(".").map(p => parseInt(p, 10) || 0);
    const maxParts = range.max.split(".").map(p => parseInt(p, 10) || 0);
    
    const afterMin = compareVersions(versionParts, minParts) >= 0;
    const beforeMax = compareVersions(versionParts, maxParts) <= 0;
    
    return {
      affected: afterMin && beforeMax,
      reason: afterMin && beforeMax
        ? `Version ${version} is between ${range.min} and ${range.max}`
        : `Version ${version} is outside range ${range.min} - ${range.max}`,
    };
  }

  if (range.max) {
    const maxParts = range.max.split(".").map(p => parseInt(p, 10) || 0);
    const beforeMax = compareVersions(versionParts, maxParts) <= 0;
    return {
      affected: beforeMax,
      reason: beforeMax
        ? `Version ${version} is at or below vulnerable version ${range.max}`
        : `Version ${version} is above vulnerable version ${range.max}`,
    };
  }

  if (range.min) {
    const minParts = range.min.split(".").map(p => parseInt(p, 10) || 0);
    const afterMin = compareVersions(versionParts, minParts) >= 0;
    return {
      affected: afterMin,
      reason: afterMin
        ? `Version ${version} is at or above minimum affected ${range.min}`
        : `Version ${version} is below minimum affected ${range.min}`,
    };
  }

  return {
    affected: false,
    reason: "No version range specified - cannot determine if affected",
  };
}

function compareVersions(a: number[], b: number[]): number {
  const maxLen = Math.max(a.length, b.length);
  
  for (let i = 0; i < maxLen; i++) {
    const aVal = a[i] || 0;
    const bVal = b[i] || 0;
    
    if (aVal > bVal) return 1;
    if (aVal < bVal) return -1;
  }
  
  return 0;
}

function getRelatedTechnologies(technology: string): string[] {
  const relationships: Record<string, string[]> = {
    wordpress: ["php", "mysql"],
    woocommerce: ["wordpress", "php"],
    "contact-form-7": ["wordpress", "php"],
    joomla: ["php", "mysql"],
    drupal: ["php", "mysql", "postgresql"],
    magento: ["php", "mysql"],
    laravel: ["php"],
    django: ["python"],
    rails: ["ruby"],
    express: ["nodejs"],
    aspnet: ["iis"],
  };
  
  return relationships[technology.toLowerCase()] || [];
}

export function validateAndFilterCVEs(
  cves: Array<{ id: string; description: string; severity: string }>,
  detectedStack: TechnologyStack
): {
  confirmed: CVEFinding[];
  possible: CVEFinding[];
  suppressed: Array<{ cveId: string; reason: string }>;
} {
  const confirmed: CVEFinding[] = [];
  const possible: CVEFinding[] = [];
  const suppressed: Array<{ cveId: string; reason: string }> = [];

  for (const cve of cves) {
    const suppressionCheck = shouldSuppressCVE(cve.id, detectedStack);
    
    if (suppressionCheck.suppress) {
      suppressed.push({
        cveId: cve.id,
        reason: suppressionCheck.reason,
      });
      continue;
    }

    const metadata = CVE_METADATA[cve.id];
    if (!metadata) {
      suppressed.push({
        cveId: cve.id,
        reason: "No metadata available for validation",
      });
      continue;
    }

    const tech = detectedStack.technologies.find(
      t => t.name.toLowerCase() === metadata.technology.toLowerCase()
    );
    
    const signals = detectedStack.signalCounts[metadata.technology.toLowerCase()];
    const signalSources = signals?.sources.map(s => s) || [];

    const finding = validateCVE(
      cve.id,
      metadata.technology,
      tech?.version || "",
      signalSources
    );

    if (!finding) {
      suppressed.push({
        cveId: cve.id,
        reason: "Validation returned null",
      });
      continue;
    }

    if (finding.category === "confirmed") {
      confirmed.push(finding);
    } else if (finding.category === "possible") {
      const downgradedFinding = {
        ...finding,
        validationDetails: [
          ...finding.validationDetails,
          `Original severity: ${cve.severity}`,
          "Severity capped at Medium for 'possible' findings",
        ],
      };
      possible.push(downgradedFinding);
    } else {
      suppressed.push({
        cveId: cve.id,
        reason: finding.suppressionReason || "Not scannable via web",
      });
    }
  }

  return { confirmed, possible, suppressed };
}

export function generateSuppressionReport(
  suppressed: Array<{ cveId: string; reason: string }>
): string {
  if (suppressed.length === 0) {
    return "No CVEs were suppressed.";
  }

  const lines = [
    "=== CVE Suppression Report ===",
    `Total suppressed: ${suppressed.length}`,
    "",
    "Detailed reasons:",
  ];

  for (const item of suppressed) {
    lines.push(`  ${item.cveId}: ${item.reason}`);
  }

  lines.push("");
  lines.push("Note: Suppression is intentional to prevent false positives.");
  lines.push("It is acceptable to miss CVEs. It is NOT acceptable to report incorrect CVEs.");

  return lines.join("\n");
}
