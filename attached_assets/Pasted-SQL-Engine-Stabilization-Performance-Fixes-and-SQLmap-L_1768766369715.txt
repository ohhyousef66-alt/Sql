SQL Engine Stabilization, Performance Fixes, and SQLmap-Level Upgrade

1. Critical Bug: Scan Freezes at ~35%
The scanner must never stall mid-scan.
Identify and fix blocking points, especially:
- Awaited async tasks that never resolve
- Deadlocks caused by time-based SQL probes
- Unbounded retries or missing timeouts
- Shared resources locked across async workers

Mandatory actions:
- Add strict timeouts to every request
- Add global watchdog for each scan phase
- If a task exceeds its budget, terminate and continue
The scan must ALWAYS complete, even if partial.

2. Performance Issues (Scanner Is Too Slow)
The current slowness is unacceptable and not caused by deep scanning alone.
Speed must be improved through logic and control, not reduced testing.

Required fixes:
- Do not block the entire scan on time-based SQL checks
- Serialize time-based probes per parameter, not globally
- Parallelize safe checks (baseline, boolean, error-based)
- Cache negative SQL results immediately and skip re-testing
- Stop scanning parameters that show zero behavioral difference early

3. SQL Injection Engine: Major Upgrade Required
The SQL engine is still below the expected level.
Upgrade it to sqlmap-level logic or better, focused ONLY on SQL.

Mandatory SQL detection order:
1) Error-based SQL injection (highest confidence, fastest)
2) Boolean-based SQL injection (primary detection)
3) Time-based blind SQL injection (confirmation / fallback)

Error-Based SQL (Must Trigger Immediately):
- If breaking context produces a database error, report SQLi instantly
- Do not suppress 500 responses or DB error output
- Detect database functions and error structures (not simple string matching)
Error-based SQLi does NOT require boolean or time-based confirmation.

Boolean-Based SQL (Core Engine):
- Establish normalized baseline response
- Execute true/false conditions
- Compare structural differences (DOM blocks, element counts)
- Require consistency across retries
No boolean differential = no SQLi.

Time-Based SQL (Controlled, Not Blocking):
- Build latency baseline per parameter
- Use incremental delays (2s â†’ 4s)
- Abort early if variance is too noisy
- Never allow time-based tests to block the scan

4. Parameter Handling (SQL-Focused)
Stop treating all parameters equally.
For testphp.vulnweb.com and similar targets:
- Prioritize known SQL-sensitive parameters (cat, artist, id)
- Classify parameters as numeric or string
- Apply payload logic accordingly

5. Speed Without Quality Loss
Speed improvements must come from:
- Early rejection of non-injectable parameters
- Intelligent escalation only when signals appear
- Avoiding repeated failed payload classes
NOT from reducing verification or payload diversity.

6. SQL-Only Scope (For Now)
Ignore all other vulnerability classes.
No CVEs.
No XSS.
No generic findings.
All effort must go into making SQL detection reliable, fast, and accurate.

7. Continuous Self-Improvement
If SQL injection is not detected on http://testphp.vulnweb.com:
- Assume the engine is incorrect
- Refine logic
- Re-test
Repeat until SQLi is consistently detected.

Acceptance condition:
The scanner must reliably detect SQL injection on testphp.vulnweb.com
using error-based or boolean-based evidence,
without freezing, and with reasonable scan time.

Focus on correctness first, then speed.
SQL detection is the product.